
/* Generated by glib-mkenums.rb ($Id$) */ 

#include "rbgprivate.h"
#include "glib-enum-types.h"



/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gbookmarkfile.h" */
GType
g_bookmark_file_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_BOOKMARK_FILE_ERROR_INVALID_URI, "G_BOOKMARK_FILE_ERROR_INVALID_URI", "invalid-uri" },
      { G_BOOKMARK_FILE_ERROR_INVALID_VALUE, "G_BOOKMARK_FILE_ERROR_INVALID_VALUE", "invalid-value" },
      { G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED, "G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED", "app-not-registered" },
      { G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND, "G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND", "uri-not-found" },
      { G_BOOKMARK_FILE_ERROR_READ, "G_BOOKMARK_FILE_ERROR_READ", "read" },
      { G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING, "G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING", "unknown-encoding" },
      { G_BOOKMARK_FILE_ERROR_WRITE, "G_BOOKMARK_FILE_ERROR_WRITE", "write" },
      { G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND, "G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND", "file-not-found" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GBookmarkFileError", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gchecksum.h" */
GType
g_checksum_type_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_CHECKSUM_MD5, "G_CHECKSUM_MD5", "md5" },
      { G_CHECKSUM_SHA1, "G_CHECKSUM_SHA1", "sha1" },
      { G_CHECKSUM_SHA256, "G_CHECKSUM_SHA256", "sha256" },
      { G_CHECKSUM_SHA512, "G_CHECKSUM_SHA512", "sha512" },
      { G_CHECKSUM_SHA384, "G_CHECKSUM_SHA384", "sha384" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GChecksumType", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gconvert.h" */
GType
g_convert_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_CONVERT_ERROR_NO_CONVERSION, "G_CONVERT_ERROR_NO_CONVERSION", "no-conversion" },
      { G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "G_CONVERT_ERROR_ILLEGAL_SEQUENCE", "illegal-sequence" },
      { G_CONVERT_ERROR_FAILED, "G_CONVERT_ERROR_FAILED", "failed" },
      { G_CONVERT_ERROR_PARTIAL_INPUT, "G_CONVERT_ERROR_PARTIAL_INPUT", "partial-input" },
      { G_CONVERT_ERROR_BAD_URI, "G_CONVERT_ERROR_BAD_URI", "bad-uri" },
      { G_CONVERT_ERROR_NOT_ABSOLUTE_PATH, "G_CONVERT_ERROR_NOT_ABSOLUTE_PATH", "not-absolute-path" },
      { G_CONVERT_ERROR_NO_MEMORY, "G_CONVERT_ERROR_NO_MEMORY", "no-memory" },
      { G_CONVERT_ERROR_EMBEDDED_NUL, "G_CONVERT_ERROR_EMBEDDED_NUL", "embedded-nul" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GConvertError", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gdate.h" */
GType
g_date_dm_y_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_DATE_DAY, "G_DATE_DAY", "day" },
      { G_DATE_MONTH, "G_DATE_MONTH", "month" },
      { G_DATE_YEAR, "G_DATE_YEAR", "year" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GDateDMY", values);
  }
  return etype;
}

GType
g_date_weekday_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_DATE_BAD_WEEKDAY, "G_DATE_BAD_WEEKDAY", "bad-weekday" },
      { G_DATE_MONDAY, "G_DATE_MONDAY", "monday" },
      { G_DATE_TUESDAY, "G_DATE_TUESDAY", "tuesday" },
      { G_DATE_WEDNESDAY, "G_DATE_WEDNESDAY", "wednesday" },
      { G_DATE_THURSDAY, "G_DATE_THURSDAY", "thursday" },
      { G_DATE_FRIDAY, "G_DATE_FRIDAY", "friday" },
      { G_DATE_SATURDAY, "G_DATE_SATURDAY", "saturday" },
      { G_DATE_SUNDAY, "G_DATE_SUNDAY", "sunday" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GDateWeekday", values);
  }
  return etype;
}

GType
g_date_month_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_DATE_BAD_MONTH, "G_DATE_BAD_MONTH", "bad-month" },
      { G_DATE_JANUARY, "G_DATE_JANUARY", "january" },
      { G_DATE_FEBRUARY, "G_DATE_FEBRUARY", "february" },
      { G_DATE_MARCH, "G_DATE_MARCH", "march" },
      { G_DATE_APRIL, "G_DATE_APRIL", "april" },
      { G_DATE_MAY, "G_DATE_MAY", "may" },
      { G_DATE_JUNE, "G_DATE_JUNE", "june" },
      { G_DATE_JULY, "G_DATE_JULY", "july" },
      { G_DATE_AUGUST, "G_DATE_AUGUST", "august" },
      { G_DATE_SEPTEMBER, "G_DATE_SEPTEMBER", "september" },
      { G_DATE_OCTOBER, "G_DATE_OCTOBER", "october" },
      { G_DATE_NOVEMBER, "G_DATE_NOVEMBER", "november" },
      { G_DATE_DECEMBER, "G_DATE_DECEMBER", "december" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GDateMonth", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gfileutils.h" */
GType
g_file_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_FILE_ERROR_EXIST, "G_FILE_ERROR_EXIST", "exist" },
      { G_FILE_ERROR_ISDIR, "G_FILE_ERROR_ISDIR", "isdir" },
      { G_FILE_ERROR_ACCES, "G_FILE_ERROR_ACCES", "acces" },
      { G_FILE_ERROR_NAMETOOLONG, "G_FILE_ERROR_NAMETOOLONG", "nametoolong" },
      { G_FILE_ERROR_NOENT, "G_FILE_ERROR_NOENT", "noent" },
      { G_FILE_ERROR_NOTDIR, "G_FILE_ERROR_NOTDIR", "notdir" },
      { G_FILE_ERROR_NXIO, "G_FILE_ERROR_NXIO", "nxio" },
      { G_FILE_ERROR_NODEV, "G_FILE_ERROR_NODEV", "nodev" },
      { G_FILE_ERROR_ROFS, "G_FILE_ERROR_ROFS", "rofs" },
      { G_FILE_ERROR_TXTBSY, "G_FILE_ERROR_TXTBSY", "txtbsy" },
      { G_FILE_ERROR_FAULT, "G_FILE_ERROR_FAULT", "fault" },
      { G_FILE_ERROR_LOOP, "G_FILE_ERROR_LOOP", "loop" },
      { G_FILE_ERROR_NOSPC, "G_FILE_ERROR_NOSPC", "nospc" },
      { G_FILE_ERROR_NOMEM, "G_FILE_ERROR_NOMEM", "nomem" },
      { G_FILE_ERROR_MFILE, "G_FILE_ERROR_MFILE", "mfile" },
      { G_FILE_ERROR_NFILE, "G_FILE_ERROR_NFILE", "nfile" },
      { G_FILE_ERROR_BADF, "G_FILE_ERROR_BADF", "badf" },
      { G_FILE_ERROR_INVAL, "G_FILE_ERROR_INVAL", "inval" },
      { G_FILE_ERROR_PIPE, "G_FILE_ERROR_PIPE", "pipe" },
      { G_FILE_ERROR_AGAIN, "G_FILE_ERROR_AGAIN", "again" },
      { G_FILE_ERROR_INTR, "G_FILE_ERROR_INTR", "intr" },
      { G_FILE_ERROR_IO, "G_FILE_ERROR_IO", "io" },
      { G_FILE_ERROR_PERM, "G_FILE_ERROR_PERM", "perm" },
      { G_FILE_ERROR_NOSYS, "G_FILE_ERROR_NOSYS", "nosys" },
      { G_FILE_ERROR_FAILED, "G_FILE_ERROR_FAILED", "failed" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GFileError", values);
  }
  return etype;
}

GType
g_file_test_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_FILE_TEST_IS_REGULAR, "G_FILE_TEST_IS_REGULAR", "is-regular" },
      { G_FILE_TEST_IS_SYMLINK, "G_FILE_TEST_IS_SYMLINK", "is-symlink" },
      { G_FILE_TEST_IS_DIR, "G_FILE_TEST_IS_DIR", "is-dir" },
      { G_FILE_TEST_IS_EXECUTABLE, "G_FILE_TEST_IS_EXECUTABLE", "is-executable" },
      { G_FILE_TEST_EXISTS, "G_FILE_TEST_EXISTS", "exists" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GFileTest", values);
  }
  return etype;
}

GType
g_file_set_contents_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_FILE_SET_CONTENTS_NONE, "G_FILE_SET_CONTENTS_NONE", "none" },
      { G_FILE_SET_CONTENTS_CONSISTENT, "G_FILE_SET_CONTENTS_CONSISTENT", "consistent" },
      { G_FILE_SET_CONTENTS_DURABLE, "G_FILE_SET_CONTENTS_DURABLE", "durable" },
      { G_FILE_SET_CONTENTS_ONLY_EXISTING, "G_FILE_SET_CONTENTS_ONLY_EXISTING", "only-existing" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GFileSetContentsFlags", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/ghook.h" */
GType
g_hook_flag_mask_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_HOOK_FLAG_ACTIVE, "G_HOOK_FLAG_ACTIVE", "active" },
      { G_HOOK_FLAG_IN_CALL, "G_HOOK_FLAG_IN_CALL", "in-call" },
      { G_HOOK_FLAG_MASK, "G_HOOK_FLAG_MASK", "mask" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GHookFlagMask", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gkeyfile.h" */
GType
g_key_file_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_KEY_FILE_ERROR_UNKNOWN_ENCODING, "G_KEY_FILE_ERROR_UNKNOWN_ENCODING", "unknown-encoding" },
      { G_KEY_FILE_ERROR_PARSE, "G_KEY_FILE_ERROR_PARSE", "parse" },
      { G_KEY_FILE_ERROR_NOT_FOUND, "G_KEY_FILE_ERROR_NOT_FOUND", "not-found" },
      { G_KEY_FILE_ERROR_KEY_NOT_FOUND, "G_KEY_FILE_ERROR_KEY_NOT_FOUND", "key-not-found" },
      { G_KEY_FILE_ERROR_GROUP_NOT_FOUND, "G_KEY_FILE_ERROR_GROUP_NOT_FOUND", "group-not-found" },
      { G_KEY_FILE_ERROR_INVALID_VALUE, "G_KEY_FILE_ERROR_INVALID_VALUE", "invalid-value" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GKeyFileError", values);
  }
  return etype;
}

GType
g_key_file_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_KEY_FILE_NONE, "G_KEY_FILE_NONE", "none" },
      { G_KEY_FILE_KEEP_COMMENTS, "G_KEY_FILE_KEEP_COMMENTS", "keep-comments" },
      { G_KEY_FILE_KEEP_TRANSLATIONS, "G_KEY_FILE_KEEP_TRANSLATIONS", "keep-translations" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GKeyFileFlags", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gmarkup.h" */
GType
g_markup_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_MARKUP_ERROR_BAD_UTF8, "G_MARKUP_ERROR_BAD_UTF8", "bad-utf8" },
      { G_MARKUP_ERROR_EMPTY, "G_MARKUP_ERROR_EMPTY", "empty" },
      { G_MARKUP_ERROR_PARSE, "G_MARKUP_ERROR_PARSE", "parse" },
      { G_MARKUP_ERROR_UNKNOWN_ELEMENT, "G_MARKUP_ERROR_UNKNOWN_ELEMENT", "unknown-element" },
      { G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, "G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE", "unknown-attribute" },
      { G_MARKUP_ERROR_INVALID_CONTENT, "G_MARKUP_ERROR_INVALID_CONTENT", "invalid-content" },
      { G_MARKUP_ERROR_MISSING_ATTRIBUTE, "G_MARKUP_ERROR_MISSING_ATTRIBUTE", "missing-attribute" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GMarkupError", values);
  }
  return etype;
}

GType
g_markup_parse_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_MARKUP_DEFAULT_FLAGS, "G_MARKUP_DEFAULT_FLAGS", "default-flags" },
      { G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG, "G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG", "do-not-use-this-unsupported-flag" },
      { G_MARKUP_TREAT_CDATA_AS_TEXT, "G_MARKUP_TREAT_CDATA_AS_TEXT", "treat-cdata-as-text" },
      { G_MARKUP_PREFIX_ERROR_POSITION, "G_MARKUP_PREFIX_ERROR_POSITION", "prefix-error-position" },
      { G_MARKUP_IGNORE_QUALIFIED, "G_MARKUP_IGNORE_QUALIFIED", "ignore-qualified" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GMarkupParseFlags", values);
  }
  return etype;
}

GType
g_markup_collect_type_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_MARKUP_COLLECT_INVALID, "G_MARKUP_COLLECT_INVALID", "invalid" },
      { G_MARKUP_COLLECT_STRING, "G_MARKUP_COLLECT_STRING", "string" },
      { G_MARKUP_COLLECT_STRDUP, "G_MARKUP_COLLECT_STRDUP", "strdup" },
      { G_MARKUP_COLLECT_BOOLEAN, "G_MARKUP_COLLECT_BOOLEAN", "boolean" },
      { G_MARKUP_COLLECT_TRISTATE, "G_MARKUP_COLLECT_TRISTATE", "tristate" },
      { G_MARKUP_COLLECT_OPTIONAL, "G_MARKUP_COLLECT_OPTIONAL", "optional" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GMarkupCollectType", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gmessages.h" */
GType
g_log_level_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_LOG_FLAG_RECURSION, "G_LOG_FLAG_RECURSION", "flag-recursion" },
      { G_LOG_FLAG_FATAL, "G_LOG_FLAG_FATAL", "flag-fatal" },
      { G_LOG_LEVEL_ERROR, "G_LOG_LEVEL_ERROR", "level-error" },
      { G_LOG_LEVEL_CRITICAL, "G_LOG_LEVEL_CRITICAL", "level-critical" },
      { G_LOG_LEVEL_WARNING, "G_LOG_LEVEL_WARNING", "level-warning" },
      { G_LOG_LEVEL_MESSAGE, "G_LOG_LEVEL_MESSAGE", "level-message" },
      { G_LOG_LEVEL_INFO, "G_LOG_LEVEL_INFO", "level-info" },
      { G_LOG_LEVEL_DEBUG, "G_LOG_LEVEL_DEBUG", "level-debug" },
      { G_LOG_LEVEL_MASK, "G_LOG_LEVEL_MASK", "level-mask" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GLogLevelFlags", values);
  }
  return etype;
}

GType
g_log_writer_output_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_LOG_WRITER_HANDLED, "G_LOG_WRITER_HANDLED", "handled" },
      { G_LOG_WRITER_UNHANDLED, "G_LOG_WRITER_UNHANDLED", "unhandled" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GLogWriterOutput", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gnode.h" */
GType
g_traverse_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_TRAVERSE_LEAVES, "G_TRAVERSE_LEAVES", "leaves" },
      { G_TRAVERSE_NON_LEAVES, "G_TRAVERSE_NON_LEAVES", "non-leaves" },
      { G_TRAVERSE_ALL, "G_TRAVERSE_ALL", "all" },
      { G_TRAVERSE_MASK, "G_TRAVERSE_MASK", "mask" },
      { G_TRAVERSE_LEAFS, "G_TRAVERSE_LEAFS", "leafs" },
      { G_TRAVERSE_NON_LEAFS, "G_TRAVERSE_NON_LEAFS", "non-leafs" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GTraverseFlags", values);
  }
  return etype;
}

GType
g_traverse_type_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_IN_ORDER, "G_IN_ORDER", "in-order" },
      { G_PRE_ORDER, "G_PRE_ORDER", "pre-order" },
      { G_POST_ORDER, "G_POST_ORDER", "post-order" },
      { G_LEVEL_ORDER, "G_LEVEL_ORDER", "level-order" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GTraverseType", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/goption.h" */
GType
g_option_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_OPTION_FLAG_NONE, "G_OPTION_FLAG_NONE", "none" },
      { G_OPTION_FLAG_HIDDEN, "G_OPTION_FLAG_HIDDEN", "hidden" },
      { G_OPTION_FLAG_IN_MAIN, "G_OPTION_FLAG_IN_MAIN", "in-main" },
      { G_OPTION_FLAG_REVERSE, "G_OPTION_FLAG_REVERSE", "reverse" },
      { G_OPTION_FLAG_NO_ARG, "G_OPTION_FLAG_NO_ARG", "no-arg" },
      { G_OPTION_FLAG_FILENAME, "G_OPTION_FLAG_FILENAME", "filename" },
      { G_OPTION_FLAG_OPTIONAL_ARG, "G_OPTION_FLAG_OPTIONAL_ARG", "optional-arg" },
      { G_OPTION_FLAG_NOALIAS, "G_OPTION_FLAG_NOALIAS", "noalias" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GOptionFlags", values);
  }
  return etype;
}

GType
g_option_arg_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_OPTION_ARG_NONE, "G_OPTION_ARG_NONE", "none" },
      { G_OPTION_ARG_STRING, "G_OPTION_ARG_STRING", "string" },
      { G_OPTION_ARG_INT, "G_OPTION_ARG_INT", "int" },
      { G_OPTION_ARG_CALLBACK, "G_OPTION_ARG_CALLBACK", "callback" },
      { G_OPTION_ARG_FILENAME, "G_OPTION_ARG_FILENAME", "filename" },
      { G_OPTION_ARG_STRING_ARRAY, "G_OPTION_ARG_STRING_ARRAY", "string-array" },
      { G_OPTION_ARG_FILENAME_ARRAY, "G_OPTION_ARG_FILENAME_ARRAY", "filename-array" },
      { G_OPTION_ARG_DOUBLE, "G_OPTION_ARG_DOUBLE", "double" },
      { G_OPTION_ARG_INT64, "G_OPTION_ARG_INT64", "int64" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GOptionArg", values);
  }
  return etype;
}

GType
g_option_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_OPTION_ERROR_UNKNOWN_OPTION, "G_OPTION_ERROR_UNKNOWN_OPTION", "unknown-option" },
      { G_OPTION_ERROR_BAD_VALUE, "G_OPTION_ERROR_BAD_VALUE", "bad-value" },
      { G_OPTION_ERROR_FAILED, "G_OPTION_ERROR_FAILED", "failed" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GOptionError", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gregex.h" */
GType
g_regex_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_REGEX_ERROR_COMPILE, "G_REGEX_ERROR_COMPILE", "compile" },
      { G_REGEX_ERROR_OPTIMIZE, "G_REGEX_ERROR_OPTIMIZE", "optimize" },
      { G_REGEX_ERROR_REPLACE, "G_REGEX_ERROR_REPLACE", "replace" },
      { G_REGEX_ERROR_MATCH, "G_REGEX_ERROR_MATCH", "match" },
      { G_REGEX_ERROR_INTERNAL, "G_REGEX_ERROR_INTERNAL", "internal" },
      { G_REGEX_ERROR_STRAY_BACKSLASH, "G_REGEX_ERROR_STRAY_BACKSLASH", "stray-backslash" },
      { G_REGEX_ERROR_MISSING_CONTROL_CHAR, "G_REGEX_ERROR_MISSING_CONTROL_CHAR", "missing-control-char" },
      { G_REGEX_ERROR_UNRECOGNIZED_ESCAPE, "G_REGEX_ERROR_UNRECOGNIZED_ESCAPE", "unrecognized-escape" },
      { G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER, "G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER", "quantifiers-out-of-order" },
      { G_REGEX_ERROR_QUANTIFIER_TOO_BIG, "G_REGEX_ERROR_QUANTIFIER_TOO_BIG", "quantifier-too-big" },
      { G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS, "G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS", "unterminated-character-class" },
      { G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS, "G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS", "invalid-escape-in-character-class" },
      { G_REGEX_ERROR_RANGE_OUT_OF_ORDER, "G_REGEX_ERROR_RANGE_OUT_OF_ORDER", "range-out-of-order" },
      { G_REGEX_ERROR_NOTHING_TO_REPEAT, "G_REGEX_ERROR_NOTHING_TO_REPEAT", "nothing-to-repeat" },
      { G_REGEX_ERROR_UNRECOGNIZED_CHARACTER, "G_REGEX_ERROR_UNRECOGNIZED_CHARACTER", "unrecognized-character" },
      { G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS, "G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS", "posix-named-class-outside-class" },
      { G_REGEX_ERROR_UNMATCHED_PARENTHESIS, "G_REGEX_ERROR_UNMATCHED_PARENTHESIS", "unmatched-parenthesis" },
      { G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE, "G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE", "inexistent-subpattern-reference" },
      { G_REGEX_ERROR_UNTERMINATED_COMMENT, "G_REGEX_ERROR_UNTERMINATED_COMMENT", "unterminated-comment" },
      { G_REGEX_ERROR_EXPRESSION_TOO_LARGE, "G_REGEX_ERROR_EXPRESSION_TOO_LARGE", "expression-too-large" },
      { G_REGEX_ERROR_MEMORY_ERROR, "G_REGEX_ERROR_MEMORY_ERROR", "memory-error" },
      { G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND, "G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND", "variable-length-lookbehind" },
      { G_REGEX_ERROR_MALFORMED_CONDITION, "G_REGEX_ERROR_MALFORMED_CONDITION", "malformed-condition" },
      { G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES, "G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES", "too-many-conditional-branches" },
      { G_REGEX_ERROR_ASSERTION_EXPECTED, "G_REGEX_ERROR_ASSERTION_EXPECTED", "assertion-expected" },
      { G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME, "G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME", "unknown-posix-class-name" },
      { G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED, "G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED", "posix-collating-elements-not-supported" },
      { G_REGEX_ERROR_HEX_CODE_TOO_LARGE, "G_REGEX_ERROR_HEX_CODE_TOO_LARGE", "hex-code-too-large" },
      { G_REGEX_ERROR_INVALID_CONDITION, "G_REGEX_ERROR_INVALID_CONDITION", "invalid-condition" },
      { G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND, "G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND", "single-byte-match-in-lookbehind" },
      { G_REGEX_ERROR_INFINITE_LOOP, "G_REGEX_ERROR_INFINITE_LOOP", "infinite-loop" },
      { G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR, "G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR", "missing-subpattern-name-terminator" },
      { G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME, "G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME", "duplicate-subpattern-name" },
      { G_REGEX_ERROR_MALFORMED_PROPERTY, "G_REGEX_ERROR_MALFORMED_PROPERTY", "malformed-property" },
      { G_REGEX_ERROR_UNKNOWN_PROPERTY, "G_REGEX_ERROR_UNKNOWN_PROPERTY", "unknown-property" },
      { G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG, "G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG", "subpattern-name-too-long" },
      { G_REGEX_ERROR_TOO_MANY_SUBPATTERNS, "G_REGEX_ERROR_TOO_MANY_SUBPATTERNS", "too-many-subpatterns" },
      { G_REGEX_ERROR_INVALID_OCTAL_VALUE, "G_REGEX_ERROR_INVALID_OCTAL_VALUE", "invalid-octal-value" },
      { G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE, "G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE", "too-many-branches-in-define" },
      { G_REGEX_ERROR_DEFINE_REPETION, "G_REGEX_ERROR_DEFINE_REPETION", "define-repetion" },
      { G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS, "G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS", "inconsistent-newline-options" },
      { G_REGEX_ERROR_MISSING_BACK_REFERENCE, "G_REGEX_ERROR_MISSING_BACK_REFERENCE", "missing-back-reference" },
      { G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE, "G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE", "invalid-relative-reference" },
      { G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN, "G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN", "backtracking-control-verb-argument-forbidden" },
      { G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB, "G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB", "unknown-backtracking-control-verb" },
      { G_REGEX_ERROR_NUMBER_TOO_BIG, "G_REGEX_ERROR_NUMBER_TOO_BIG", "number-too-big" },
      { G_REGEX_ERROR_MISSING_SUBPATTERN_NAME, "G_REGEX_ERROR_MISSING_SUBPATTERN_NAME", "missing-subpattern-name" },
      { G_REGEX_ERROR_MISSING_DIGIT, "G_REGEX_ERROR_MISSING_DIGIT", "missing-digit" },
      { G_REGEX_ERROR_INVALID_DATA_CHARACTER, "G_REGEX_ERROR_INVALID_DATA_CHARACTER", "invalid-data-character" },
      { G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME, "G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME", "extra-subpattern-name" },
      { G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED, "G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED", "backtracking-control-verb-argument-required" },
      { G_REGEX_ERROR_INVALID_CONTROL_CHAR, "G_REGEX_ERROR_INVALID_CONTROL_CHAR", "invalid-control-char" },
      { G_REGEX_ERROR_MISSING_NAME, "G_REGEX_ERROR_MISSING_NAME", "missing-name" },
      { G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS, "G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS", "not-supported-in-class" },
      { G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES, "G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES", "too-many-forward-references" },
      { G_REGEX_ERROR_NAME_TOO_LONG, "G_REGEX_ERROR_NAME_TOO_LONG", "name-too-long" },
      { G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE, "G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE", "character-value-too-large" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GRegexError", values);
  }
  return etype;
}

GType
g_regex_compile_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_REGEX_DEFAULT, "G_REGEX_DEFAULT", "default" },
      { G_REGEX_CASELESS, "G_REGEX_CASELESS", "caseless" },
      { G_REGEX_MULTILINE, "G_REGEX_MULTILINE", "multiline" },
      { G_REGEX_DOTALL, "G_REGEX_DOTALL", "dotall" },
      { G_REGEX_EXTENDED, "G_REGEX_EXTENDED", "extended" },
      { G_REGEX_ANCHORED, "G_REGEX_ANCHORED", "anchored" },
      { G_REGEX_DOLLAR_ENDONLY, "G_REGEX_DOLLAR_ENDONLY", "dollar-endonly" },
      { G_REGEX_UNGREEDY, "G_REGEX_UNGREEDY", "ungreedy" },
      { G_REGEX_RAW, "G_REGEX_RAW", "raw" },
      { G_REGEX_NO_AUTO_CAPTURE, "G_REGEX_NO_AUTO_CAPTURE", "no-auto-capture" },
      { G_REGEX_OPTIMIZE, "G_REGEX_OPTIMIZE", "optimize" },
      { G_REGEX_FIRSTLINE, "G_REGEX_FIRSTLINE", "firstline" },
      { G_REGEX_DUPNAMES, "G_REGEX_DUPNAMES", "dupnames" },
      { G_REGEX_NEWLINE_CR, "G_REGEX_NEWLINE_CR", "newline-cr" },
      { G_REGEX_NEWLINE_LF, "G_REGEX_NEWLINE_LF", "newline-lf" },
      { G_REGEX_NEWLINE_CRLF, "G_REGEX_NEWLINE_CRLF", "newline-crlf" },
      { G_REGEX_NEWLINE_ANYCRLF, "G_REGEX_NEWLINE_ANYCRLF", "newline-anycrlf" },
      { G_REGEX_BSR_ANYCRLF, "G_REGEX_BSR_ANYCRLF", "bsr-anycrlf" },
      { G_REGEX_JAVASCRIPT_COMPAT, "G_REGEX_JAVASCRIPT_COMPAT", "javascript-compat" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GRegexCompileFlags", values);
  }
  return etype;
}

GType
g_regex_match_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_REGEX_MATCH_DEFAULT, "G_REGEX_MATCH_DEFAULT", "default" },
      { G_REGEX_MATCH_ANCHORED, "G_REGEX_MATCH_ANCHORED", "anchored" },
      { G_REGEX_MATCH_NOTBOL, "G_REGEX_MATCH_NOTBOL", "notbol" },
      { G_REGEX_MATCH_NOTEOL, "G_REGEX_MATCH_NOTEOL", "noteol" },
      { G_REGEX_MATCH_NOTEMPTY, "G_REGEX_MATCH_NOTEMPTY", "notempty" },
      { G_REGEX_MATCH_PARTIAL, "G_REGEX_MATCH_PARTIAL", "partial" },
      { G_REGEX_MATCH_NEWLINE_CR, "G_REGEX_MATCH_NEWLINE_CR", "newline-cr" },
      { G_REGEX_MATCH_NEWLINE_LF, "G_REGEX_MATCH_NEWLINE_LF", "newline-lf" },
      { G_REGEX_MATCH_NEWLINE_CRLF, "G_REGEX_MATCH_NEWLINE_CRLF", "newline-crlf" },
      { G_REGEX_MATCH_NEWLINE_ANY, "G_REGEX_MATCH_NEWLINE_ANY", "newline-any" },
      { G_REGEX_MATCH_NEWLINE_ANYCRLF, "G_REGEX_MATCH_NEWLINE_ANYCRLF", "newline-anycrlf" },
      { G_REGEX_MATCH_BSR_ANYCRLF, "G_REGEX_MATCH_BSR_ANYCRLF", "bsr-anycrlf" },
      { G_REGEX_MATCH_BSR_ANY, "G_REGEX_MATCH_BSR_ANY", "bsr-any" },
      { G_REGEX_MATCH_PARTIAL_SOFT, "G_REGEX_MATCH_PARTIAL_SOFT", "partial-soft" },
      { G_REGEX_MATCH_PARTIAL_HARD, "G_REGEX_MATCH_PARTIAL_HARD", "partial-hard" },
      { G_REGEX_MATCH_NOTEMPTY_ATSTART, "G_REGEX_MATCH_NOTEMPTY_ATSTART", "notempty-atstart" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GRegexMatchFlags", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gshell.h" */
GType
g_shell_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_SHELL_ERROR_BAD_QUOTING, "G_SHELL_ERROR_BAD_QUOTING", "bad-quoting" },
      { G_SHELL_ERROR_EMPTY_STRING, "G_SHELL_ERROR_EMPTY_STRING", "empty-string" },
      { G_SHELL_ERROR_FAILED, "G_SHELL_ERROR_FAILED", "failed" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GShellError", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gslice.h" */
GType
g_slice_config_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_SLICE_CONFIG_ALWAYS_MALLOC, "G_SLICE_CONFIG_ALWAYS_MALLOC", "always-malloc" },
      { G_SLICE_CONFIG_BYPASS_MAGAZINES, "G_SLICE_CONFIG_BYPASS_MAGAZINES", "bypass-magazines" },
      { G_SLICE_CONFIG_WORKING_SET_MSECS, "G_SLICE_CONFIG_WORKING_SET_MSECS", "working-set-msecs" },
      { G_SLICE_CONFIG_COLOR_INCREMENT, "G_SLICE_CONFIG_COLOR_INCREMENT", "color-increment" },
      { G_SLICE_CONFIG_CHUNK_SIZES, "G_SLICE_CONFIG_CHUNK_SIZES", "chunk-sizes" },
      { G_SLICE_CONFIG_CONTENTION_COUNTER, "G_SLICE_CONFIG_CONTENTION_COUNTER", "contention-counter" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GSliceConfig", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gspawn.h" */
GType
g_spawn_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_SPAWN_ERROR_FORK, "G_SPAWN_ERROR_FORK", "fork" },
      { G_SPAWN_ERROR_READ, "G_SPAWN_ERROR_READ", "read" },
      { G_SPAWN_ERROR_CHDIR, "G_SPAWN_ERROR_CHDIR", "chdir" },
      { G_SPAWN_ERROR_ACCES, "G_SPAWN_ERROR_ACCES", "acces" },
      { G_SPAWN_ERROR_PERM, "G_SPAWN_ERROR_PERM", "perm" },
      { G_SPAWN_ERROR_TOO_BIG, "G_SPAWN_ERROR_TOO_BIG", "too-big" },
      { G_SPAWN_ERROR_2BIG, "G_SPAWN_ERROR_2BIG", "2big" },
      { G_SPAWN_ERROR_NOEXEC, "G_SPAWN_ERROR_NOEXEC", "noexec" },
      { G_SPAWN_ERROR_NAMETOOLONG, "G_SPAWN_ERROR_NAMETOOLONG", "nametoolong" },
      { G_SPAWN_ERROR_NOENT, "G_SPAWN_ERROR_NOENT", "noent" },
      { G_SPAWN_ERROR_NOMEM, "G_SPAWN_ERROR_NOMEM", "nomem" },
      { G_SPAWN_ERROR_NOTDIR, "G_SPAWN_ERROR_NOTDIR", "notdir" },
      { G_SPAWN_ERROR_LOOP, "G_SPAWN_ERROR_LOOP", "loop" },
      { G_SPAWN_ERROR_TXTBUSY, "G_SPAWN_ERROR_TXTBUSY", "txtbusy" },
      { G_SPAWN_ERROR_IO, "G_SPAWN_ERROR_IO", "io" },
      { G_SPAWN_ERROR_NFILE, "G_SPAWN_ERROR_NFILE", "nfile" },
      { G_SPAWN_ERROR_MFILE, "G_SPAWN_ERROR_MFILE", "mfile" },
      { G_SPAWN_ERROR_INVAL, "G_SPAWN_ERROR_INVAL", "inval" },
      { G_SPAWN_ERROR_ISDIR, "G_SPAWN_ERROR_ISDIR", "isdir" },
      { G_SPAWN_ERROR_LIBBAD, "G_SPAWN_ERROR_LIBBAD", "libbad" },
      { G_SPAWN_ERROR_FAILED, "G_SPAWN_ERROR_FAILED", "failed" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GSpawnError", values);
  }
  return etype;
}

GType
g_spawn_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_SPAWN_DEFAULT, "G_SPAWN_DEFAULT", "default" },
      { G_SPAWN_LEAVE_DESCRIPTORS_OPEN, "G_SPAWN_LEAVE_DESCRIPTORS_OPEN", "leave-descriptors-open" },
      { G_SPAWN_DO_NOT_REAP_CHILD, "G_SPAWN_DO_NOT_REAP_CHILD", "do-not-reap-child" },
      { G_SPAWN_SEARCH_PATH, "G_SPAWN_SEARCH_PATH", "search-path" },
      { G_SPAWN_STDOUT_TO_DEV_NULL, "G_SPAWN_STDOUT_TO_DEV_NULL", "stdout-to-dev-null" },
      { G_SPAWN_STDERR_TO_DEV_NULL, "G_SPAWN_STDERR_TO_DEV_NULL", "stderr-to-dev-null" },
      { G_SPAWN_CHILD_INHERITS_STDIN, "G_SPAWN_CHILD_INHERITS_STDIN", "child-inherits-stdin" },
      { G_SPAWN_FILE_AND_ARGV_ZERO, "G_SPAWN_FILE_AND_ARGV_ZERO", "file-and-argv-zero" },
      { G_SPAWN_SEARCH_PATH_FROM_ENVP, "G_SPAWN_SEARCH_PATH_FROM_ENVP", "search-path-from-envp" },
      { G_SPAWN_CLOEXEC_PIPES, "G_SPAWN_CLOEXEC_PIPES", "cloexec-pipes" },
      { G_SPAWN_CHILD_INHERITS_STDOUT, "G_SPAWN_CHILD_INHERITS_STDOUT", "child-inherits-stdout" },
      { G_SPAWN_CHILD_INHERITS_STDERR, "G_SPAWN_CHILD_INHERITS_STDERR", "child-inherits-stderr" },
      { G_SPAWN_STDIN_FROM_DEV_NULL, "G_SPAWN_STDIN_FROM_DEV_NULL", "stdin-from-dev-null" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GSpawnFlags", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gstrfuncs.h" */
GType
g_ascii_type_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_ASCII_ALNUM, "G_ASCII_ALNUM", "alnum" },
      { G_ASCII_ALPHA, "G_ASCII_ALPHA", "alpha" },
      { G_ASCII_CNTRL, "G_ASCII_CNTRL", "cntrl" },
      { G_ASCII_DIGIT, "G_ASCII_DIGIT", "digit" },
      { G_ASCII_GRAPH, "G_ASCII_GRAPH", "graph" },
      { G_ASCII_LOWER, "G_ASCII_LOWER", "lower" },
      { G_ASCII_PRINT, "G_ASCII_PRINT", "print" },
      { G_ASCII_PUNCT, "G_ASCII_PUNCT", "punct" },
      { G_ASCII_SPACE, "G_ASCII_SPACE", "space" },
      { G_ASCII_UPPER, "G_ASCII_UPPER", "upper" },
      { G_ASCII_XDIGIT, "G_ASCII_XDIGIT", "xdigit" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GAsciiType", values);
  }
  return etype;
}

GType
g_number_parser_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_NUMBER_PARSER_ERROR_INVALID, "G_NUMBER_PARSER_ERROR_INVALID", "invalid" },
      { G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS, "G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS", "out-of-bounds" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GNumberParserError", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gtestutils.h" */
GType
g_test_trap_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_TEST_TRAP_DEFAULT, "G_TEST_TRAP_DEFAULT", "default" },
      { G_TEST_TRAP_SILENCE_STDOUT, "G_TEST_TRAP_SILENCE_STDOUT", "silence-stdout" },
      { G_TEST_TRAP_SILENCE_STDERR, "G_TEST_TRAP_SILENCE_STDERR", "silence-stderr" },
      { G_TEST_TRAP_INHERIT_STDIN, "G_TEST_TRAP_INHERIT_STDIN", "inherit-stdin" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GTestTrapFlags", values);
  }
  return etype;
}

GType
g_test_subprocess_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_TEST_SUBPROCESS_DEFAULT, "G_TEST_SUBPROCESS_DEFAULT", "default" },
      { G_TEST_SUBPROCESS_INHERIT_STDIN, "G_TEST_SUBPROCESS_INHERIT_STDIN", "inherit-stdin" },
      { G_TEST_SUBPROCESS_INHERIT_STDOUT, "G_TEST_SUBPROCESS_INHERIT_STDOUT", "inherit-stdout" },
      { G_TEST_SUBPROCESS_INHERIT_STDERR, "G_TEST_SUBPROCESS_INHERIT_STDERR", "inherit-stderr" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GTestSubprocessFlags", values);
  }
  return etype;
}

GType
g_test_result_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_TEST_RUN_SUCCESS, "G_TEST_RUN_SUCCESS", "success" },
      { G_TEST_RUN_SKIPPED, "G_TEST_RUN_SKIPPED", "skipped" },
      { G_TEST_RUN_FAILURE, "G_TEST_RUN_FAILURE", "failure" },
      { G_TEST_RUN_INCOMPLETE, "G_TEST_RUN_INCOMPLETE", "incomplete" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GTestResult", values);
  }
  return etype;
}

GType
g_test_log_type_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_TEST_LOG_NONE, "G_TEST_LOG_NONE", "none" },
      { G_TEST_LOG_ERROR, "G_TEST_LOG_ERROR", "error" },
      { G_TEST_LOG_START_BINARY, "G_TEST_LOG_START_BINARY", "start-binary" },
      { G_TEST_LOG_LIST_CASE, "G_TEST_LOG_LIST_CASE", "list-case" },
      { G_TEST_LOG_SKIP_CASE, "G_TEST_LOG_SKIP_CASE", "skip-case" },
      { G_TEST_LOG_START_CASE, "G_TEST_LOG_START_CASE", "start-case" },
      { G_TEST_LOG_STOP_CASE, "G_TEST_LOG_STOP_CASE", "stop-case" },
      { G_TEST_LOG_MIN_RESULT, "G_TEST_LOG_MIN_RESULT", "min-result" },
      { G_TEST_LOG_MAX_RESULT, "G_TEST_LOG_MAX_RESULT", "max-result" },
      { G_TEST_LOG_MESSAGE, "G_TEST_LOG_MESSAGE", "message" },
      { G_TEST_LOG_START_SUITE, "G_TEST_LOG_START_SUITE", "start-suite" },
      { G_TEST_LOG_STOP_SUITE, "G_TEST_LOG_STOP_SUITE", "stop-suite" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GTestLogType", values);
  }
  return etype;
}

GType
g_test_file_type_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_TEST_DIST, "G_TEST_DIST", "dist" },
      { G_TEST_BUILT, "G_TEST_BUILT", "built" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GTestFileType", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gthread.h" */
GType
g_thread_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_THREAD_ERROR_AGAIN, "G_THREAD_ERROR_AGAIN", "again" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GThreadError", values);
  }
  return etype;
}

GType
g_once_status_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_ONCE_STATUS_NOTCALLED, "G_ONCE_STATUS_NOTCALLED", "notcalled" },
      { G_ONCE_STATUS_PROGRESS, "G_ONCE_STATUS_PROGRESS", "progress" },
      { G_ONCE_STATUS_READY, "G_ONCE_STATUS_READY", "ready" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GOnceStatus", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gtimezone.h" */
GType
g_time_type_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_TIME_TYPE_STANDARD, "G_TIME_TYPE_STANDARD", "standard" },
      { G_TIME_TYPE_DAYLIGHT, "G_TIME_TYPE_DAYLIGHT", "daylight" },
      { G_TIME_TYPE_UNIVERSAL, "G_TIME_TYPE_UNIVERSAL", "universal" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GTimeType", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/guri.h" */
GType
g_uri_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_URI_FLAGS_NONE, "G_URI_FLAGS_NONE", "none" },
      { G_URI_FLAGS_PARSE_RELAXED, "G_URI_FLAGS_PARSE_RELAXED", "parse-relaxed" },
      { G_URI_FLAGS_HAS_PASSWORD, "G_URI_FLAGS_HAS_PASSWORD", "has-password" },
      { G_URI_FLAGS_HAS_AUTH_PARAMS, "G_URI_FLAGS_HAS_AUTH_PARAMS", "has-auth-params" },
      { G_URI_FLAGS_ENCODED, "G_URI_FLAGS_ENCODED", "encoded" },
      { G_URI_FLAGS_NON_DNS, "G_URI_FLAGS_NON_DNS", "non-dns" },
      { G_URI_FLAGS_ENCODED_QUERY, "G_URI_FLAGS_ENCODED_QUERY", "encoded-query" },
      { G_URI_FLAGS_ENCODED_PATH, "G_URI_FLAGS_ENCODED_PATH", "encoded-path" },
      { G_URI_FLAGS_ENCODED_FRAGMENT, "G_URI_FLAGS_ENCODED_FRAGMENT", "encoded-fragment" },
      { G_URI_FLAGS_SCHEME_NORMALIZE, "G_URI_FLAGS_SCHEME_NORMALIZE", "scheme-normalize" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GUriFlags", values);
  }
  return etype;
}

GType
g_uri_hide_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_URI_HIDE_NONE, "G_URI_HIDE_NONE", "none" },
      { G_URI_HIDE_USERINFO, "G_URI_HIDE_USERINFO", "userinfo" },
      { G_URI_HIDE_PASSWORD, "G_URI_HIDE_PASSWORD", "password" },
      { G_URI_HIDE_AUTH_PARAMS, "G_URI_HIDE_AUTH_PARAMS", "auth-params" },
      { G_URI_HIDE_QUERY, "G_URI_HIDE_QUERY", "query" },
      { G_URI_HIDE_FRAGMENT, "G_URI_HIDE_FRAGMENT", "fragment" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GUriHideFlags", values);
  }
  return etype;
}

GType
g_uri_params_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_URI_PARAMS_NONE, "G_URI_PARAMS_NONE", "none" },
      { G_URI_PARAMS_CASE_INSENSITIVE, "G_URI_PARAMS_CASE_INSENSITIVE", "case-insensitive" },
      { G_URI_PARAMS_WWW_FORM, "G_URI_PARAMS_WWW_FORM", "www-form" },
      { G_URI_PARAMS_PARSE_RELAXED, "G_URI_PARAMS_PARSE_RELAXED", "parse-relaxed" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GUriParamsFlags", values);
  }
  return etype;
}

GType
g_uri_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_URI_ERROR_FAILED, "G_URI_ERROR_FAILED", "failed" },
      { G_URI_ERROR_BAD_SCHEME, "G_URI_ERROR_BAD_SCHEME", "bad-scheme" },
      { G_URI_ERROR_BAD_USER, "G_URI_ERROR_BAD_USER", "bad-user" },
      { G_URI_ERROR_BAD_PASSWORD, "G_URI_ERROR_BAD_PASSWORD", "bad-password" },
      { G_URI_ERROR_BAD_AUTH_PARAMS, "G_URI_ERROR_BAD_AUTH_PARAMS", "bad-auth-params" },
      { G_URI_ERROR_BAD_HOST, "G_URI_ERROR_BAD_HOST", "bad-host" },
      { G_URI_ERROR_BAD_PORT, "G_URI_ERROR_BAD_PORT", "bad-port" },
      { G_URI_ERROR_BAD_PATH, "G_URI_ERROR_BAD_PATH", "bad-path" },
      { G_URI_ERROR_BAD_QUERY, "G_URI_ERROR_BAD_QUERY", "bad-query" },
      { G_URI_ERROR_BAD_FRAGMENT, "G_URI_ERROR_BAD_FRAGMENT", "bad-fragment" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GUriError", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gutils.h" */
GType
g_user_directory_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_USER_DIRECTORY_DESKTOP, "G_USER_DIRECTORY_DESKTOP", "directory-desktop" },
      { G_USER_DIRECTORY_DOCUMENTS, "G_USER_DIRECTORY_DOCUMENTS", "directory-documents" },
      { G_USER_DIRECTORY_DOWNLOAD, "G_USER_DIRECTORY_DOWNLOAD", "directory-download" },
      { G_USER_DIRECTORY_MUSIC, "G_USER_DIRECTORY_MUSIC", "directory-music" },
      { G_USER_DIRECTORY_PICTURES, "G_USER_DIRECTORY_PICTURES", "directory-pictures" },
      { G_USER_DIRECTORY_PUBLIC_SHARE, "G_USER_DIRECTORY_PUBLIC_SHARE", "directory-public-share" },
      { G_USER_DIRECTORY_TEMPLATES, "G_USER_DIRECTORY_TEMPLATES", "directory-templates" },
      { G_USER_DIRECTORY_VIDEOS, "G_USER_DIRECTORY_VIDEOS", "directory-videos" },
      { G_USER_N_DIRECTORIES, "G_USER_N_DIRECTORIES", "n-directories" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GUserDirectory", values);
  }
  return etype;
}

GType
g_format_size_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_FORMAT_SIZE_DEFAULT, "G_FORMAT_SIZE_DEFAULT", "default" },
      { G_FORMAT_SIZE_LONG_FORMAT, "G_FORMAT_SIZE_LONG_FORMAT", "long-format" },
      { G_FORMAT_SIZE_IEC_UNITS, "G_FORMAT_SIZE_IEC_UNITS", "iec-units" },
      { G_FORMAT_SIZE_BITS, "G_FORMAT_SIZE_BITS", "bits" },
      { G_FORMAT_SIZE_ONLY_VALUE, "G_FORMAT_SIZE_ONLY_VALUE", "only-value" },
      { G_FORMAT_SIZE_ONLY_UNIT, "G_FORMAT_SIZE_ONLY_UNIT", "only-unit" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GFormatSizeFlags", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/glib/gvariant.h" */
GType
g_variant_class_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_VARIANT_CLASS_BOOLEAN, "G_VARIANT_CLASS_BOOLEAN", "boolean" },
      { G_VARIANT_CLASS_BYTE, "G_VARIANT_CLASS_BYTE", "byte" },
      { G_VARIANT_CLASS_INT16, "G_VARIANT_CLASS_INT16", "int16" },
      { G_VARIANT_CLASS_UINT16, "G_VARIANT_CLASS_UINT16", "uint16" },
      { G_VARIANT_CLASS_INT32, "G_VARIANT_CLASS_INT32", "int32" },
      { G_VARIANT_CLASS_UINT32, "G_VARIANT_CLASS_UINT32", "uint32" },
      { G_VARIANT_CLASS_INT64, "G_VARIANT_CLASS_INT64", "int64" },
      { G_VARIANT_CLASS_UINT64, "G_VARIANT_CLASS_UINT64", "uint64" },
      { G_VARIANT_CLASS_HANDLE, "G_VARIANT_CLASS_HANDLE", "handle" },
      { G_VARIANT_CLASS_DOUBLE, "G_VARIANT_CLASS_DOUBLE", "double" },
      { G_VARIANT_CLASS_STRING, "G_VARIANT_CLASS_STRING", "string" },
      { G_VARIANT_CLASS_OBJECT_PATH, "G_VARIANT_CLASS_OBJECT_PATH", "object-path" },
      { G_VARIANT_CLASS_SIGNATURE, "G_VARIANT_CLASS_SIGNATURE", "signature" },
      { G_VARIANT_CLASS_VARIANT, "G_VARIANT_CLASS_VARIANT", "variant" },
      { G_VARIANT_CLASS_MAYBE, "G_VARIANT_CLASS_MAYBE", "maybe" },
      { G_VARIANT_CLASS_ARRAY, "G_VARIANT_CLASS_ARRAY", "array" },
      { G_VARIANT_CLASS_TUPLE, "G_VARIANT_CLASS_TUPLE", "tuple" },
      { G_VARIANT_CLASS_DICT_ENTRY, "G_VARIANT_CLASS_DICT_ENTRY", "dict-entry" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GVariantClass", values);
  }
  return etype;
}

GType
g_variant_parse_error_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GEnumValue values[] = {
      { G_VARIANT_PARSE_ERROR_FAILED, "G_VARIANT_PARSE_ERROR_FAILED", "failed" },
      { G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED, "G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED", "basic-type-expected" },
      { G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE, "G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE", "cannot-infer-type" },
      { G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED, "G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED", "definite-type-expected" },
      { G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END, "G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END", "input-not-at-end" },
      { G_VARIANT_PARSE_ERROR_INVALID_CHARACTER, "G_VARIANT_PARSE_ERROR_INVALID_CHARACTER", "invalid-character" },
      { G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING, "G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING", "invalid-format-string" },
      { G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH, "G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH", "invalid-object-path" },
      { G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE, "G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE", "invalid-signature" },
      { G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING, "G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING", "invalid-type-string" },
      { G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE, "G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE", "no-common-type" },
      { G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE, "G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE", "number-out-of-range" },
      { G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG, "G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG", "number-too-big" },
      { G_VARIANT_PARSE_ERROR_TYPE_ERROR, "G_VARIANT_PARSE_ERROR_TYPE_ERROR", "type-error" },
      { G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN, "G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN", "unexpected-token" },
      { G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD, "G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD", "unknown-keyword" },
      { G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT, "G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT", "unterminated-string-constant" },
      { G_VARIANT_PARSE_ERROR_VALUE_EXPECTED, "G_VARIANT_PARSE_ERROR_VALUE_EXPECTED", "value-expected" },
      { G_VARIANT_PARSE_ERROR_RECURSION, "G_VARIANT_PARSE_ERROR_RECURSION", "recursion" },
      { 0, NULL, NULL }
    };
    etype = g_enum_register_static ("GVariantParseError", values);
  }
  return etype;
}


/* enumerations from "/usr/local/Cellar/glib/2.78.0/include/glib-2.0/gobject/gsignal.h" */
GType
g_signal_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_SIGNAL_RUN_FIRST, "G_SIGNAL_RUN_FIRST", "run-first" },
      { G_SIGNAL_RUN_LAST, "G_SIGNAL_RUN_LAST", "run-last" },
      { G_SIGNAL_RUN_CLEANUP, "G_SIGNAL_RUN_CLEANUP", "run-cleanup" },
      { G_SIGNAL_NO_RECURSE, "G_SIGNAL_NO_RECURSE", "no-recurse" },
      { G_SIGNAL_DETAILED, "G_SIGNAL_DETAILED", "detailed" },
      { G_SIGNAL_ACTION, "G_SIGNAL_ACTION", "action" },
      { G_SIGNAL_NO_HOOKS, "G_SIGNAL_NO_HOOKS", "no-hooks" },
      { G_SIGNAL_MUST_COLLECT, "G_SIGNAL_MUST_COLLECT", "must-collect" },
      { G_SIGNAL_DEPRECATED, "G_SIGNAL_DEPRECATED", "deprecated" },
      { G_SIGNAL_ACCUMULATOR_FIRST_RUN, "G_SIGNAL_ACCUMULATOR_FIRST_RUN", "accumulator-first-run" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GSignalFlags", values);
  }
  return etype;
}

GType
g_connect_flags_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_CONNECT_DEFAULT, "G_CONNECT_DEFAULT", "default" },
      { G_CONNECT_AFTER, "G_CONNECT_AFTER", "after" },
      { G_CONNECT_SWAPPED, "G_CONNECT_SWAPPED", "swapped" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GConnectFlags", values);
  }
  return etype;
}

GType
g_signal_match_type_get_type (void)
{
  static GType etype = 0;
  if (etype == 0) {
    static const GFlagsValue values[] = {
      { G_SIGNAL_MATCH_ID, "G_SIGNAL_MATCH_ID", "id" },
      { G_SIGNAL_MATCH_DETAIL, "G_SIGNAL_MATCH_DETAIL", "detail" },
      { G_SIGNAL_MATCH_CLOSURE, "G_SIGNAL_MATCH_CLOSURE", "closure" },
      { G_SIGNAL_MATCH_FUNC, "G_SIGNAL_MATCH_FUNC", "func" },
      { G_SIGNAL_MATCH_DATA, "G_SIGNAL_MATCH_DATA", "data" },
      { G_SIGNAL_MATCH_UNBLOCKED, "G_SIGNAL_MATCH_UNBLOCKED", "unblocked" },
      { 0, NULL, NULL }
    };
    etype = g_flags_register_static ("GSignalMatchType", values);
  }
  return etype;
}


/* Generated data ends here */

